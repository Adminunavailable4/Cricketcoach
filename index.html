<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CricCoach Lite</title>
    
    <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>

    <style>
        body {
            margin: 0;
            background: #000;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* The Container for Video & Canvas */
        #cam-container {
            position: relative;
            width: 100vw;
            height: 70vh;
            background: #222;
        }

        /* The raw video element (hidden but active) */
        video {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        /* The drawing layer (Skeleton) */
        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            object-fit: cover;
        }

        /* Loading Bar */
        #loader-overlay {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10;
            padding: 20px;
            text-align: center;
            color: #00f3ff;
            transition: opacity 0.5s;
        }

        .progress-bar {
            width: 80%;
            height: 4px;
            background: #333;
            margin: 10px auto;
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            width: 0%; /* Starts empty */
            height: 100%;
            background: #00f3ff;
            animation: loadAnim 2s infinite;
        }

        @keyframes loadAnim {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Controls */
        #controls {
            height: 30vh;
            width: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 5;
        }

        #feedback-text {
            color: #fff;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
        }

        .btn-group { display: flex; gap: 20px; }

        button {
            padding: 12px 30px;
            background: transparent;
            border: 1px solid #00f3ff;
            color: #00f3ff;
            font-size: 1rem;
            border-radius: 20px;
        }
        button.active { background: #00f3ff; color: #000; font-weight: bold; }

    </style>
</head>
<body>

    <div id="cam-container">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="canvas"></canvas>
        
        <div id="loader-overlay">
            <div id="status-msg">Starting Camera...</div>
            <div class="progress-bar"><div class="progress-fill"></div></div>
        </div>
    </div>

    <div id="controls">
        <div id="feedback-text">WAITING FOR AI...</div>
        <div class="btn-group">
            <button id="btn-bat" class="active" onclick="setMode('batting')">BAT</button>
            <button id="btn-bowl" onclick="setMode('bowling')">BOWL</button>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusMsg = document.getElementById('status-msg');
        const feedback = document.getElementById('feedback-text');
        
        let poseNet;
        let currentMode = 'batting';
        let isAIReady = false;

        // 1. START CAMERA IMMEDIATELY (No waiting)
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 },
                    audio: false
                });
                video.srcObject = stream;
                statusMsg.innerText = "Camera Active! Downloading AI...";
                
                // Once video plays, set canvas size match
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    loadAI(); // Start downloading AI only after camera works
                };
            } catch (err) {
                statusMsg.innerText = "Error: Allow Camera Permission!";
                statusMsg.style.color = "red";
            }
        }

        // 2. LOAD AI IN BACKGROUND
        function loadAI() {
            // Options optimized for speed
            const options = {
                architecture: 'MobileNetV1',
                imageScaleFactor: 0.3,
                outputStride: 16,
                flipHorizontal: true,
                minConfidence: 0.5,
                multiplier: 0.50 // Smallest model size
            };

            poseNet = ml5.poseNet(video, options, () => {
                isAIReady = true;
                // Hide Loader
                document.getElementById('loader-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('loader-overlay').style.display = 'none', 500);
                feedback.innerText = "READY!";
                loop(); // Start the loop
            });

            poseNet.on('pose', (results) => {
                if(results.length > 0) analyze(results[0].pose);
            });
        }

        // 3. THE LOOP (Draws lines and checks logic)
        function loop() {
            if(!isAIReady) return;
            
            // Clear previous lines
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // We rely on the 'pose' event for data, 
            // but we need a loop to keep the UI responsive if needed.
            requestAnimationFrame(loop);
        }

        function analyze(pose) {
            // Draw Skeleton
            drawSkeleton(pose);

            // Run Logic
            if (currentMode === 'batting') {
                // Stance Logic
                let kneeY = (pose.leftKnee.y + pose.rightKnee.y) / 2;
                let hipY = (pose.leftHip.y + pose.rightHip.y) / 2;
                let diff = kneeY - hipY;

                if (diff > 80) { // Threshold for bent knees
                    feedback.innerText = "✅ GOOD STANCE";
                    feedback.style.color = "#00ff00";
                } else {
                    feedback.innerText = "⚠️ BEND KNEES";
                    feedback.style.color = "yellow";
                }
            } else {
                // Bowling Logic
                if (pose.rightWrist.y < pose.nose.y) {
                    feedback.innerText = "✅ HIGH ARM";
                    feedback.style.color = "#00ff00";
                } else {
                    feedback.innerText = "⚠️ LIFT ARM";
                    feedback.style.color = "yellow";
                }
            }
        }

        function drawSkeleton(pose) {
            ctx.strokeStyle = "#00f3ff";
            ctx.lineWidth = 3;
            ctx.fillStyle = "#fff";

            // Helper to draw line
            const connect = (p1, p2) => {
                if(p1.score > 0.5 && p2.score > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            };

            // Draw Body
            connect(pose.leftShoulder, pose.rightShoulder);
            connect(pose.leftShoulder, pose.leftHip);
            connect(pose.rightShoulder, pose.rightHip);
            connect(pose.leftHip, pose.rightHip); // Hip line
            
            // Arms
            connect(pose.leftShoulder, pose.leftElbow);
            connect(pose.leftElbow, pose.leftWrist);
            connect(pose.rightShoulder, pose.rightElbow);
            connect(pose.rightElbow, pose.rightWrist);

            // Draw dots
            pose.keypoints.forEach(p => {
                if(p.score > 0.5) {
                    ctx.beginPath();
                    ctx.arc(p.position.x, p.position.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btn-bat').className = mode === 'batting' ? 'active' : '';
            document.getElementById('btn-bowl').className = mode === 'bowling' ? 'active' : '';
        }

        // Start everything
        startCamera();

    </script>
</body>
</html>

